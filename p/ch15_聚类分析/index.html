<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='biopython官方教程学习笔记'><title>ch15_聚类分析</title>

<link rel='canonical' href='https://example.com/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='ch15_聚类分析'>
<meta property='og:description' content='biopython官方教程学习笔记'>
<meta property='og:url' content='https://example.com/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/'>
<meta property='og:site_name' content='叶宇浩随记博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='tutorials' /><meta property='article:published_time' content='2021-08-15T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-08-15T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="ch15_聚类分析">
<meta name="twitter:description" content="biopython官方教程学习笔记">
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/biopython/" style="background-color: #002be1; color: #fff;">
                生物编程
            </a>
        
            <a href="/categories/bioinformatic/" style="background-color: #7816ff; color: #fff;">
                生物信息学&amp;计算生物学
            </a>
        
            <a href="/categories/deeplearning/" style="background-color: #0f1503; color: #fff;">
                深度学习
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/">ch15_聚类分析</a>
    </h2>

    
    <h3 class="article-subtitle">
        biopython官方教程学习笔记
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Aug 15, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    10 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p><strong>biopython官方地址：</strong><a class="link" href="https://biopython.org/"  target="_blank" rel="noopener"
    ><strong>https://biopython.org/</strong></a></p>
<p><strong>github地址：</strong><a class="link" href="https://github.com/biopython/biopython/blob/master/README.rst"  target="_blank" rel="noopener"
    ><strong>https://github.com/biopython/biopython/blob/master/</strong></a></p>
<p><strong>中文版教程：</strong><a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr06.html"  target="_blank" rel="noopener"
    ><strong>https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr06.html</strong></a></p>
<p><strong>biopython包的说明（具体到每个模块了）：</strong><a class="link" href="https://www.osgeo.cn/biopython/Bio.HMM.DynamicProgramming.html"  target="_blank" rel="noopener"
    ><strong>https://www.osgeo.cn/biopython/Bio.HMM.DynamicProgramming.html</strong></a></p>
<p>聚类分析是根据元素相似度，进行分组的过程。在生物信息学中，聚类分析广泛 用于基因表达数据分析，用来对具有相似表达谱的基因归类；从而鉴定功能相关的基 因，或预测未知基因的功能。<br>
Biopython中的 Bio.Cluster 模块提供了常用的聚类算法。虽然Bio.Cluster被设计用于 基因表达数据，它也可用于其他类型数据的聚类。 Bio.Cluster 和其使用的C聚类库的说明见De Hoon <em>et al.</em> [<a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr23.html#dehoon2004"  target="_blank" rel="noopener"
    >14</a>].<br>
Bio.Cluster 包含了以下四种聚类算法：</p>
<ul>
<li>系统聚类（成对重心法，最短距离，最大距离和平均连锁法);</li>
<li><em>k</em>-means, <em>k</em>-medians, 和 <em>k</em>-medoids 聚类;</li>
<li>自组织映射（Self-Organizing Maps）;</li>
<li>主成分分析
<strong>数据表示法</strong><br>
用于聚类的输入为一个 <em>n</em> x <em>m</em> 的Python 数值矩阵 data。在基因表达数据聚类中， 每一行表示不同的基因，每一列表示不同的实验条件。 Bio.Cluster 既可以 针对每行（基因），也可以针对每列（实验条件）进行聚类。<br>
<strong>缺失值</strong><br>
在芯片实验中，经常会有些缺失值，可以用一个额外的 <em>n</em> × <em>m</em> Numerical Python 整型矩阵 mask 表示。
例如 mask[i,j] ,表示 data[i,j] 是个缺失值， 并且在分析中被忽略。<br>
<strong>随机数据生成器</strong><br>
<em>k</em>-means/medians/medoids 聚类和 Self-Organizing Maps (SOMs) 需要调用随机数生成器。在 Bio.Cluster 中，正态分布随机数 生成器的算法是基于L’Ecuyer [<a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr23.html#lecuyer1988"  target="_blank" rel="noopener"
    >25</a>] ，二项分布的随机数 生成器算法是基于Kachitvichyanukul and Schmeiser [<a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr23.html#kachitvichyanukul1988"  target="_blank" rel="noopener"
    >23</a>] 开发的BTPE算法。随机数生成器在调用时会首先进行初始化。由于随机数生成器使用了 两个乘同余发生器（multiplicative linear congruential generators），所以初始化时需要两个整型的 种子。这两个种子可以调用系统提供的 rand （C标准库）函数生成。在 Bio.Cluster 中， 我们首先调用 srand 使用以秒为单位的时间戳的值初始值，再用 rand 随机产生两 个随机数作为种子来产生正态分布的随机数。</li>
</ul>
<h2 id="距离函数">距离函数</h2>
<p>为了对元素根据相似度进行聚类，第一步需要定义相似度。Bio.Cluster 提供了八种不同 的距离函数来衡量相似度或者距离，分别用不同的字母代表：</p>
<ul>
<li>&rsquo;e&rsquo;: Euclidean 距离;</li>
<li>&lsquo;b&rsquo;: City-block 距离.</li>
<li>&lsquo;c&rsquo;: Pearson 相关系数;</li>
<li>&lsquo;a&rsquo;: Pearson相关系数的绝对值;</li>
<li>&lsquo;u&rsquo;: Uncentered Pearson correlation （相当于两个数据向量的夹角余弦值）</li>
<li>&lsquo;x&rsquo;: uncentered Pearson correlation的绝对值;</li>
<li>&rsquo;s&rsquo;: Spearman’s 秩相关系数;</li>
<li>&lsquo;k&rsquo;: Kendall’s τ.
<figure 
	
		class="gallery-image" 
		style="
			flex-grow: 211; 
			flex-basis: 508px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90.png" data-size="864x408">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90.png"
			width="864"
			height="408"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90_hubac27672e6accabd431f42ba15d62fdc_160402_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90_hubac27672e6accabd431f42ba15d62fdc_160402_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></li>
</ul>
<h3 id="euclidean距离">Euclidean距离</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 365; 
			flex-basis: 876px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-1.png" data-size="840x230">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-1.png"
			width="840"
			height="230"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-1_huff3e7615a61a704286f0a2adc18dd6f3_86190_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-1_huff3e7615a61a704286f0a2adc18dd6f3_86190_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="city-block-distance">City-block distance</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 288; 
			flex-basis: 693px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-2.png" data-size="838x290">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-2.png"
			width="838"
			height="290"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-2_hu9a26b7c3aeec0d8910e4c533a09a5500_161994_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-2_hu9a26b7c3aeec0d8910e4c533a09a5500_161994_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h2 id="pearson相关系数">pearson相关系数</h2>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 189; 
			flex-basis: 455px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-3.png" data-size="846x446">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-3.png"
			width="846"
			height="446"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-3_hu1f890bbbc5a51bf9f6415f26e08ca05d_167148_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-3_hu1f890bbbc5a51bf9f6415f26e08ca05d_167148_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="absolute-pearson-correlation">Absolute Pearson correlation</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 232; 
			flex-basis: 557px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-4.png" data-size="836x360">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-4.png"
			width="836"
			height="360"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-4_hua6a5851ba8b1da3325751f64e0505fe1_150642_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-4_hua6a5851ba8b1da3325751f64e0505fe1_150642_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="uncentered-correlation-夹角余弦">Uncentered correlation (夹角余弦)</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 104; 
			flex-basis: 251px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-5.png" data-size="846x806">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-5.png"
			width="846"
			height="806"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-5_hub3adad83e3639c5a9bc02551faff8bf1_273908_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-5_hub3adad83e3639c5a9bc02551faff8bf1_273908_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="absolute-uncentered-correlation">Absolute uncentered correlation</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 312; 
			flex-basis: 750px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-6.png" data-size="832x266">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-6.png"
			width="832"
			height="266"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-6_hu8c52d6f3df225ecbc7faf88989204742_122662_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-6_hu8c52d6f3df225ecbc7faf88989204742_122662_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="spearman-rank-correlation">Spearman rank correlation</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 244; 
			flex-basis: 587px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-7.png" data-size="822x336">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-7.png"
			width="822"
			height="336"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-7_hu19f47440ba44cbcdacd96d17a5197117_153208_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-7_hu19f47440ba44cbcdacd96d17a5197117_153208_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="kendalls-τ">Kendall&rsquo;s τ</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 336; 
			flex-basis: 808px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-8.png" data-size="808x240">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-8.png"
			width="808"
			height="240"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-8_hu85352f51dbd04a46bfe8b2319d99c709_92889_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-8_hu85352f51dbd04a46bfe8b2319d99c709_92889_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h2 id="weighting">Weighting</h2>
<p>对于 Bio.Cluster 中大部分距离函数，都可以使用加权向量。加权向量包含着 数据集中每个元素的权重。如果元素 <em>i</em> 的权重为 <em>w__i</em>，那么将会认为该元素 出现了 <em>w__i</em> 次 。权重值可以不为整数。对于 Spearman 秩相关系数 和Kendall’s τ, 权重没有太大的意义，因此不适用于这两个函数。</p>
<h2 id="计算距离矩阵">计算距离矩阵</h2>
<p>距离矩阵是 data 中，所有元素的两两间的距离的平方矩阵，可以用 Bio.Cluster 模块中 distancematrix 函数计算：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">distancematrix</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">matrix</span> <span class="o">=</span> <span class="n">distancematrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>其中，包含以下参数：</p>
<ul>
<li>**data (必选)**包含所有元素的矩阵</li>
<li>**mask (默认: None)**缺失数据矩阵。若 mask[i,j]0, 则 data[i,j] 缺失。若 maskNone, 表明没有缺失数据。</li>
<li>**weight (默认: None)**权重矩阵。若 weight==None, 则假设所有的数据使用相同的权重。</li>
<li>**transpose (默认: 0)**选择使用 data 中的行 (transpose0), 或者列 (transpose1)来计算距离.</li>
<li><strong>dist (默认: &rsquo;e&rsquo;, Euclidean distance)</strong>
为了节省内存，函数返回的距离矩阵是一个一维数组的列表。每行的列数等于行号。 因此，第一行有0个元素。例如：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="p">[</span><span class="n">array</span><span class="p">([]),</span>
</span></span><span class="line"><span class="cl"> <span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl"> <span class="n">array</span><span class="p">([</span><span class="mf">7.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl"> <span class="n">array</span><span class="p">([</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">])]</span>
</span></span></code></pre></div><p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 427; 
			flex-basis: 1026px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-9.png" data-size="838x196">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-9.png"
			width="838"
			height="196"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-9_hud3845a8a4804173668b7e81df461d833_26590_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-9_hud3845a8a4804173668b7e81df461d833_26590_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h2 id="计算类的相关性质">计算类的相关性质</h2>
<h3 id="计算类中心">计算类中心</h3>
<p>类中心可以定义为该类中在每个维度上所有元素的平均值或者中值，可以用 Bio.Cluster 中的 clustercentroids 函数计算：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">clustercentroids</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">cmask</span> <span class="o">=</span> <span class="n">clustercentroids</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>包含了以下参数:</p>
<ul>
<li>**data (必选)**包含所有元素的矩阵。</li>
<li>**mask (默认: None)**缺失数据矩阵。若 mask[i,j]0, 则 data[i,j] 缺失。若 maskNone, 则明没有缺失数据。</li>
<li>**clusterid (默认: None)**一个表示每个元素的所属类的整型向量。如果 clusterid 是 None, 表明所有的元素属于相同的类。</li>
<li>**method (默认: &lsquo;a&rsquo;)**指定使用算术平方根 (method&rsquo;a&rsquo;) 或者中值(method&rsquo;m&rsquo;) 来计算类中心。</li>
<li>**transpose (默认: 0)**选择使用 data 中的行 (transpose0), 或者列 (transpose1) 来计算类中心.
这个函数返回值为元组 (cdata, cmask)。 类中心的数据存储在一个二维的Numerical Python 数组 cdata 中, 缺失值的结果存储在二维的Numerical Python整型数组 cmask 中。 当 transpose = 0 时， 这两个数组的维度是（类数，列数），当 transpose = 1 时，数组的长度为 （行数，类数）。 其中每一行（当 transpose = 0) 或者 每一列（当 transpose = 1 ） 包含着对应每类对应的数据的平均值。</li>
</ul>
<h3 id="计算类间距离">计算类间距离</h3>
<p>根据每个 <em>items</em> 的距离函数，我们可以计算出两个 <em>clusters</em> 的距离。两个类别的 算术平均值之间的距离通常用于重心法聚类和 <em>k</em>-means 聚类，而 <em>k</em>-medoids 聚类中，通常利用两类的中值进行计算。最短距离法利用的是两类间最近的元素之间的距离， 而最大距离法利用最长的元素之间的距离。在两两平均连锁聚类法中， 类间的距离定义为类内所有对应元素两两间距离的平均值。<br>
为了计算两类之间的距离，可以利用:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">clusterdistance</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">clusterdistance</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>其中，包含的参数有：</p>
<ul>
<li>**data (必选)**包含所有元素的矩阵。</li>
<li>**mask (默认: None)**缺失数据矩阵。若 mask[i,j]0, 则 data[i,j] 缺失。若 maskNone, 则明没有缺失数据。</li>
<li>**weight (默认: None)**权重矩阵。若 weight等于None, 则假设所有的数据使用相同的权重。</li>
<li>**index1 (默认: 0)**第一个类所包含的元素索引的列表。如果一个类别只包含一个元素 <em>i</em> ，则数据类型 可以为一个列表 [i], 或者整数 i.</li>
<li>**index2 (默认: 0)**第二个类所包含的元素的列表。如果一个类别只包含一个元素 <em>i</em> ，则数据类型 可以为一个列表 [i], 或者整数 i.</li>
<li>**method (默认: &lsquo;a&rsquo;)**选择计算类别间距离的方法:
<ul>
<li>&lsquo;a&rsquo;: 使用两个类中心的距离 (算术平均值);</li>
<li>&rsquo;m&rsquo;: 使用两个类中心的距离 (中值);</li>
<li>&rsquo;s&rsquo;: 使用两类中最短的两个元素之间的距离;</li>
<li>&lsquo;x&rsquo;: 使用两类中最长的两个元素之间的距离;</li>
<li>&lsquo;v&rsquo;: 使用两类中对应元素间的距离的平均值作为距离。</li>
</ul>
</li>
<li>**dist (默认: &rsquo;e&rsquo;, Euclidean distance)**选择距离函数 .</li>
<li>**transpose (默认: 0)**选择使用 data 中的行 (transpose0), 或者列 (transpose1)来计算距离.</li>
</ul>
<h2 id="划分算法">划分算法</h2>
<p>划分算法依据所有元素到各自聚类中心距离之和最小化原则， 将元素分为 <em>k</em> 类。类的个数 <em>k</em> 由用户定义。 Bio.Cluster 提供了三种不同 的算法:</p>
<ul>
<li><em>k</em>-means 聚类</li>
<li><em>k</em>-medians 聚类</li>
<li><em>k</em>-medoids 聚类
这些算法的区别在于如何定义聚类中心。在 <em>k</em>-means 中, 聚类中心定义为该类中所有 元素的平均值。 在 <em>k</em>-medians 聚类中， 利用每个维度的中间值来计算。 最后， <em>k</em>-medoids 聚类中，聚类中心定义为该类中，距离其他所有元素距离之和最小的元素所在的位置。 这个方法适用于已知距离矩阵，但是原始数据矩阵未知的情况，例如根据结构相似度对蛋白进行聚类<br>
expectation-maximization (EM) 算法通常用于将数据分成 <em>k</em> 组。在 EM算法的起始阶段, 随机的把元素分配到不同的组。为了保证所有的类都包含元素，可以利用二项分布的方法随机 为每类挑选元素。然后，随机的对分组进行排列，保证每个元素有相同的概率被分到任何一个类别。 最终，保证每类中至少含有一个元素。<br>
之后进行迭代:</li>
<li>利用均值，中值或者medoid计算每类的中心;</li>
<li>计算每类的元素离各自中心的距离;</li>
<li>对于每个元素，判别其离哪个聚类中心最近;</li>
<li>将元素重新分配到最近的聚类，当不能进行调整时，迭代终止。
为了避免迭代中产生空的类别，在 <em>k</em>-means 和 <em>k</em>-medians 聚类中，算法始终记录着每类中元素的 个数，并且阻止最后一个元素被分到其他的类别中。对于 <em>k</em>-medoids 聚类, 这种检查就是没有必要的， 因为当只剩最后一个元素时，它离中心的距离为0，所以不会被分配到其他的类别中。<br>
由于起始阶段的每类中的元素分配是随机的，而通常当EM算法执行时，可能产生不同的聚类结果。为了找到最优的聚类结果， 可以对进行 <em>k</em>-means 算法重复多次，每次都以不同的随机分配作为起始。每次运行后，都会保存所有元素距离 其中心距离之和，并且选择总距离最小的运行结果最为最终的结果。<br>
EM算法运行的次数取决于需要聚类元素的多少。一般而言，我们可以根据最优解被发现的次数来选择。 这个次数会作为划分算法的返回值。如果最优解被多次返回，那么不太可能存在比这个 更优的解。然后，如果最优解只被发现一次，那么可能存在着距离更小的解。但是，如果需要聚类的 元素过多的话（多余几百），那么很难找到一个全局最优解。<br>
EM算法会在不能进行任何分配的时候停止。我们注意到，在某些随机的起始分配中，由于 相同的解会在迭代中周期性的重复，从而导致EM算法的失败。因此，我们在迭代中也会 检查是否有周期性出现的解存在。首先，在给定数目的迭代后，当前的聚类结果会保存作为一个参考。之后 继续迭代一定次数，比较该结果同之前保存的结果，可以确定之前的结果是否重复出现。 如果有重复出现，迭代会终止。如果没有出现，那么再次迭代后的结果会保存作为新的参考。 通常，会首先重复10次迭代，再保存结果为新的参考。之后，迭代的次数会翻倍，保证在长的周期中也可以 检测到该解。</li>
</ul>
<h3 id="k-means-and-k-medians">K-means and k-medians</h3>
<p><em>k</em>-means 和 <em>k</em>-medians 算法可以利用 Bio.Cluster<code>中的</code> kcluster 实现:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">kcluster</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">clusterid</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nfound</span> <span class="o">=</span> <span class="n">kcluster</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>其中，包含的参数有：</p>
<ul>
<li>**data (必选)**包含所有元素的矩阵。</li>
<li>**nclusters (默认: 2)**期望的类的数目 <em>k</em>.</li>
<li>**mask (默认: None)**缺失数据矩阵。若 mask[i,j]0, 则 data[i,j] 缺失。若 maskNone, 则明没有缺失数据。</li>
<li>**weight (默认: None)**权重矩阵。若 weight=None, 则假设所有的数据使用相同的权重。</li>
<li>**transpose (默认: 0)**选择使用 data 中的行 (transpose0), 或者列 (transpose1)来计算距离. - npass (默认: 1) <em>k</em>-means/-medians 聚类算法运行的次数，每次运行使用不同的随机的起始值。 如果指定了 initialid , 程序会忽略<code>npass</code> 的值，并且聚类算法只会运行一次。</li>
<li>**method (默认: a)**指定聚类中心计算方法:当指定 method 使用其他值时，算法会采用算数平均值。
<ul>
<li>method=&lsquo;a&rsquo;: 算数平均值 (<em>k</em>-means clustering);</li>
<li>method=&rsquo;m&rsquo;: 中值 (<em>k</em>-medians clustering).</li>
</ul>
</li>
<li>**dist (默认: &rsquo;e&rsquo;, Euclidean distance)**选择距离函数 (具体见 <a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr15.html#sec-distancefunctions"  target="_blank" rel="noopener"
    >15.1</a> ). 尽管八种距离都可以用于 kcluster 计算, 但从经验上来讲，Euclidean 距离适合 <em>k</em>-means 算法, city-block 距离适合 <em>k</em>-medians.</li>
<li>**initialid (默认: None)**指定EM算法运行初始的聚类类别。如果 initialid=None, 那么每运行一次EM算法时， 都会采取不同的随机初始聚类，总共运行的次数由 npass 决定。如果 initialid 不是 None, 那么它应该为一个长度为类别数的1维数组，每类中至少含有一个元素。通常当初始分类确定后，EM算法的结果也就确定了。
这个函数的返回值为一个包含 (clusterid, error, nfound) 的元组，其中 clusterid 是 一个整型矩阵，为每行或列所在的类。 error 是最优聚类解中，每类内距离的总和， nfound 指的是最优解出现的次数。</li>
</ul>
<h3 id="k-medoids聚类">k-medoids聚类</h3>
<p>kmedoids 函数根据提供的距离矩阵和聚类数，来运行 <em>k</em>-medoids 聚类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">kmedoids</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">clusterid</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nfound</span> <span class="o">=</span> <span class="n">kmedoids</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
</span></span></code></pre></div><p>其中，包含的参数有: , nclusters=2, npass=1, initialid=None)|</p>
<ul>
<li>**distance (必选)**两两元素间的距离矩阵，可以通过三种不同的方法提供：
<ul>
<li>提供一个2D的 Numerical Python 数组 (函数只会使用矩阵里左下角数据):</li>
</ul>
</li>
<li></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">distance</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">                  <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">                  <span class="p">[</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
</span></span></code></pre></div><p>输入一个一维的 Numerical Python 数组，包含了距离矩阵左下角的数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">distance</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span>
</span></span></code></pre></div><p>输入一个列表，包含距离矩阵左下角的数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">distance</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">([]</span><span class="o">|</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl">            <span class="n">array</span><span class="p">([</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">           <span class="p">]</span>
</span></span></code></pre></div><p>三种方法对应着同样的距离矩阵。</p>
<ul>
<li>**nclusters (默认: 2)**期望的类的数目 <em>k</em>.</li>
<li><strong>npass (默认: 1)</strong><em>k</em>-medoids 聚类算法运行的次数，每次运行使用不同的随机的起始值。 如果指定了 initialid , npass 的值会忽略，并且聚类算法只会运行一次。</li>
<li>**initialid (默认: None)**指定EM算法运行初始的聚类类别。如果 initialid=None, 那么每运行一次EM算法时， 都会采取不同的随机初始聚类，总共运行的次数由 npass 决定。如果 initialid 不是 None, 那么它应该为一个长度为类别数的1维数组，每类中至少含有一个元素。通常当初始分类确定后，EM算法的结果也就确定了
函数返回值为一个 包含 (clusterid, error, nfound) 的元组, 其中 clusterid 一个整型矩阵，为每行或列类所在的类。error 是在最优解中，类内距离的总和， nfound 指的是最优解出现的次数。需要注意的是， clusterid 中的类号是指的是代表聚类中心的元素号</li>
</ul>
<h2 id="系统聚类">系统聚类</h2>
<p>系统聚类同 <em>k</em>-means 聚类有本质的不同。在系统聚类中，基因间或者实验条件间的相似度是通过 树的形式展现出来的。由于可以利用Treeview或者Java Treeview来查看这些树的结构，因此系统聚类在基因表达谱数据中得到普遍应用。<br>
系统聚类的第一步是计算所有元素间的距离矩阵。之后，融合两个最近的元素成为一个节点。然后，不断的 通过融合相近的元素或者节点来形成新的节点，直到所有的元素都属于同一个节点。在追溯元素和节点融合 的过程的同时形成了树的结构。不同于 <em>k</em>-means 使用的EM算法，系统聚类的过程是固定的。<br>
系统聚类也存在着几个不同的方法，他们区别在于如何计算子节点间的距离。在 Bio.Cluster 中，提供了最短距离法（ pairwise single）,最长距离法（maximum）, 类平均法（average）, 和重心法（centroid linkage）。</p>
<ul>
<li>在最短距离法中，节点间的距离被定义两个节点最近样品间距离。</li>
<li>在最短距离法中，节点间的距离被定义两个节点最远样品间距离。</li>
<li>在类平均法中，节点间的距离被定义为所有样品对之间的平均距离。</li>
<li>在重心法中，节点间的距离被定义为两个节点重心间的距离。重心的计算是通过对 每类中所有元素进行计算的。由于每次都要计算新的节点与 其他元素和已存在节点的距离， 因此重心法的运行时间比其他系统聚类的方法更长。该方法另外一个特性是，当聚类树的 长大的时候，距离并不会增加，有时候反而减少。这是由于使用Pearson相关系数作为距离时， 对重心的计算和距离的计算不一致产生:因为Pearson相关系数在计算距离时会对数据进行有效归一化，， 但是重心的计算不会存在该种归一化。
对于最短距离法，最长距离法和类平均法时，两个节点之间的距离是直接对类别里的元素计算得到的。 因此，聚类的算法在得到距离矩阵后，不一定需要提供最开始的基因表达数据。而对于重心法而言， 新生成的节点的中心必须依靠原始的数据，而不是仅仅依靠距离矩阵。<br>
最短距离法的实现是根据 SLINK algorithm (R. Sibson, 1973), 这个算法具有快速和高效的特点。 并且这个方法聚类的结果同传统的方法结果一致。并且该算法，也可以有效的运用于大量的数据，而传统的 算法则需要大量的内存需求和运行时间。</li>
</ul>
<h3 id="展示系统聚类的结果">展示系统聚类的结果</h3>
<p>系统聚类的结果是用树的结构展示所有节点，每个节点包含两个元素或者子节点。通常，我们既关心那个元素 或者哪个子节点互相融合，也关心二者之间的距离（或者相似度）。我们可以调用 Bio.Cluster 中的 Node 类，来存储聚类树的一个节点。 Node 的实例包含以下三个属性：</p>
<ul>
<li>left</li>
<li>right</li>
<li>distance
其中, left 和 right 是合并到该节点两个元素或子节点的编号。 distance 指的是二者间的距离。其中元素的编号是从0到（元素数目-1）， 而聚类的组别是从-1到-（元素数目-1）。请注意，节点的数目比元素的数目少一。<br>
为了创建一个新的 Node 对象,我们需要指定 left 和 right; distance 是可选的。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">Node</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.91</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mf">0.91</span>
</span></span></code></pre></div><p>对于已存在 Node 对象的 left, right, 和 distance 都是可以直接修改的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="mf">0.73</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">node</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="mf">0.73</span>
</span></span></code></pre></div><p>当 left 和 right 不是整数的时候，或者 distance 不能被转化成浮点值，会抛出错误。<br>
Python的类 Tree 包含着整个系统聚类的结果。 Tree 的对象可以通过 一个 Node 的列表创建:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">   <span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">Tree</span>
</span></span><span class="line"><span class="cl">   <span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mf">0.6</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.9</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">   <span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="n">tree</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="mf">0.2</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mf">0.5</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span> <span class="mf">0.6</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">):</span> <span class="mf">0.9</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#Tree 的初始器会检查包含节点的列表是否是一个正确的系统聚类树的结果:</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="err">?</span>
</span></span><span class="line"><span class="cl"><span class="ne">ValueError</span><span class="p">:</span> <span class="n">Inconsistent</span> <span class="n">tree</span>
</span></span></code></pre></div><p>也可以使用中括号来对 Tree 对象进行检索：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="mf">0.2</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="mf">0.5</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="mf">0.5</span>
</span></span></code></pre></div><p>因为 Tree 对象是只读的，我们不能对 Tree 对象中任何一个节点进行改变。然而，我们可以将其 转换成一个节点的列表，对列表进行操作，最后创建新的树。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">([</span><span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">Node</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.9</span><span class="p">)])</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="n">tree</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="mf">0.1</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="mf">0.5</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mf">0.9</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[:]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="n">tree</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="mf">0.2</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="mf">0.5</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mf">0.9</span>
</span></span></code></pre></div><p>这个性质保证了<code>Tree</code> 结果的正确性。<br>
为了利用可视化工具，例如Java Treeview，来查看系统聚类树，最好对所有节点的距离进行标准化， 使其位于0和1之间。可以通过对 Tree 对象调用 scale 方法来实现这个功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span><span class="o">.</span><span class="n">scale</span><span class="p">()</span>
</span></span></code></pre></div><p>这个方法不需要任何参数，返回值是 None.<br>
经过系统聚类后，可以对 Tree 对象进行剪接，将所有的元素分为 <em>k</em> 类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">clusterid</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">nclusters</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></div><p>其中 nclusters (默认是 1) 是期望的类别数 <em>k</em>。这个方法会忽略树结构里面的 最高的 _k_−1 节点，最终形成 <em>k</em> 个独立的类别。对于 <em>k</em> 必须为正数，并且小于或者等于 元素的数目。这个方法会返回一个数组 clusterid ,包含着每个元素对应的类</p>
<h3 id="运行系统聚类">运行系统聚类</h3>
<p>为了进行系统聚类，可以用 Bio.Cluster 中的 treecluster 函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">treecluster</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">treecluster</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>包括以下参数:</p>
<ul>
<li><strong>data</strong>包含所有元素的矩阵。</li>
<li>**mask (默认: None)**缺失数据矩阵。若 mask[i,j]0, 则 data[i,j] 缺失。若 maskNone, 则明没有缺失数据。</li>
<li>**weight (默认: None)**权重矩阵。若 weight=None, 则假设所有的数据使用相同的权重。</li>
<li>**transpose (默认: 0)**选择使用 data 中的行 (transpose0), 或者列 (transpose1)来计算距离.</li>
<li>**method (默认: &rsquo;m&rsquo;)**选择节点间距离计算方法:
<ul>
<li>method=&rsquo;s&rsquo;: 最小距离法</li>
<li>method=&rsquo;m&rsquo;: 最大距离法</li>
<li>method=&lsquo;c&rsquo;: 重心法</li>
<li>method=&lsquo;a&rsquo;: 类平均法</li>
</ul>
</li>
<li>**dist (默认: &rsquo;e&rsquo;, Euclidean distance)**选择距离函数.
为了对距离矩阵进行系统聚类，可以在调用 treecluster 时， 用 distancematrix 参数来代替 data 参数：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">treecluster</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">treecluster</span><span class="p">(</span><span class="n">distancematrix</span><span class="o">=</span><span class="n">distance</span><span class="p">)</span><span class="err">```</span>
</span></span><span class="line"><span class="cl"><span class="n">这种情况下</span><span class="err">，</span><span class="n">需要定义下列参数</span><span class="err">：</span>
</span></span><span class="line"><span class="cl"><span class="o">-</span>   <span class="o">**</span><span class="n">distancematrix</span><span class="o">**</span><span class="n">元素两两间的距离矩阵</span><span class="err">，</span><span class="n">可以通过三种不同的方法提供</span><span class="err">：</span>
</span></span><span class="line"><span class="cl">    <span class="o">-</span>   <span class="n">提供一个2D的</span> <span class="n">Numerical</span> <span class="n">Python</span> <span class="n">数组</span> <span class="p">(</span><span class="n">函数只会使用矩阵里左下角数据</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">-</span> 
</span></span><span class="line"><span class="cl"><span class="err">```</span><span class="n">python</span>
</span></span><span class="line"><span class="cl"><span class="n">distance</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">                  <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">                  <span class="p">[</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
</span></span></code></pre></div><ul>
<li>输入一个一维的 Numerical Python 数组，包含了距离矩阵左下角的数据：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">distance</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span>
</span></span></code></pre></div><ul>
<li>输入一个列表，包含距离矩阵左下角的数据：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">distance</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">([]),</span>
</span></span><span class="line"><span class="cl">            <span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl">            <span class="n">array</span><span class="p">([</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span>
</span></span></code></pre></div><ul>
<li>三种方法对应着同样的距离矩阵。由于 treecluster 会对距离矩阵中的值进行随机洗牌， 如果后面需要调用这个距离矩阵，请在调用 treecluster 之情，事先存到一个新的变量</li>
<li><strong>method</strong>选择节点间距离计算方法:其中，最小距离法、最大距离法和类平均法可以只通过距离矩阵计算，而重心法却不行。
<ul>
<li>method=&rsquo;s&rsquo;: 最小距离法</li>
<li>method=&rsquo;m&rsquo;: 最大距离法</li>
<li>method=&lsquo;a&rsquo;: 类平均法
当调用 treecluster<code>时,</code> data 或者 distancematrix 总有一个必须为 None。<br>
函数返回一个 Tree 对象，该对象包含着 (元素数目-1）个节点，当选择行作为聚类时，元素的 数目同行数一致；当使用列作为聚类时，元素的数目同列数一致。每个节点都意味着一对相邻连锁的 事件，其中节点的性质 left 和 right 包含着每个合并的元素或者子节点的编号， distance 是两个合并元素或者子节点的距离。元素编号是从 0 到 (元素数目 − 1) , 而类别是从 -1 到 −(元素 数目 -1 ）</li>
</ul>
</li>
</ul>
<h2 id="self-organizing-maps">Self-Organizing Maps</h2>
<p>Self-Organizing Maps (SOMs) 是由 Kohonen 在描述神经网络的时候发明的 (see for instance Kohonen, 1997 [<a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr23.html#kohonen1997"  target="_blank" rel="noopener"
    >24</a>] ). Tamayo (1999) 第一次讲 Self-Organizing Maps 应用到基因表达数据上。 [<a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr23.html#tamayo1999"  target="_blank" rel="noopener"
    >30</a>].<br>
SOMs 根据某种拓扑结果将元素进行分类。通常选用的是矩形的拓扑结构。在SOMs生成的类别中，相邻的 两个类的拓扑结构相似度高于他们对其他的相似度。<br>
计算SOM的第一步是随机分配数据向量到每个类别中，如果使用行进行聚类，那么每个数据向量中的元素 个数等于列数。<br>
一个SOM 会一次读入一行，并且找到该向量最近的拓扑聚类结构。之后利用找到的数据向量对 这个类别的数据向量和相邻的类别的数据向量进行调整。调整如下<br>
<figure 
	
		class="gallery-image" 
		style="
			flex-grow: 144; 
			flex-basis: 347px"
	>
	<a href="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-10.png" data-size="830x574">
		<img src="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-10.png"
			width="830"
			height="574"
			srcset="/p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-10_hu7464df7ccfe2dc1344dd91e211491812_159914_480x0_resize_box_3.png 480w, /p/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/picture/ch15_%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-10_hu7464df7ccfe2dc1344dd91e211491812_159914_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure>
其中 (<em>N__x</em>, <em>N__y</em>) 是定义拓扑结构的矩形维度。<br>
函数 somcluster 可以用来在一个矩形的网格里计算 Self-Organizing Map。 首先，初始化一个随机数产生器。利用随机化产生器来对节点数据进行初始化。在SOM中， 基因或者芯片的调整顺序同样是随机的。用户可以定义总的SOM迭代的次数。<br>
运行 somcluster, 例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">somcluster</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">clusterid</span><span class="p">,</span> <span class="n">celldata</span> <span class="o">=</span> <span class="n">somcluster</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>其中，可以定义一下参数:</p>
<ul>
<li>**data (required)**包含所有元素的矩阵。</li>
<li>**mask (默认: None)**缺失数据矩阵。若 mask[i,j]0, 则 data[i,j] 缺失。若 maskNone, 则明没有缺失数据。</li>
<li>**weight (默认: None)**权重矩阵。若 weight=None, 则假设所有的数据使用相同的权重。</li>
<li>**transpose (默认: 0)**选择使用 data 中的行 (transpose0), 或者列 (transpose1)来聚类.</li>
<li>**nxgrid, nygrid (默认: 2, 1)**当Self-Organizing Map计算的时候，矩形的网格所包含的横向和纵向的格子。</li>
<li>**inittau (默认: 0.02)**SOM算法中，参数 τ 的初始值，默认是 0.02。 这个初始值同Michael Eisen’s Cluster/TreeView 一致。</li>
<li>**niter (默认: 1)**迭代运行的次数。</li>
<li>**dist (默认: &rsquo;e&rsquo;, Euclidean distance)**选择距离函数 (具体见 <a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr15.html#sec-distancefunctions"  target="_blank" rel="noopener"
    >15.1</a> ).
这个函数返回的是一个元组 (clusterid, celldata):</li>
<li>**clusterid:**一个两列的数组，行的数目等于待聚类元素的个数。每行包含着在矩形SOM网格中，将每个元素分配到的 格子的 <em>x</em> 和 <em>y</em> 的坐标。</li>
<li>**celldata:**当以行进行聚类时，生成的矩阵维度为 (nxgrid, nygrid, number of columns)； 当以列进行聚类时，生成的矩阵维度为 (nxgrid, nygrid, number of rows)。 在这个矩阵里， [ix][iy] 表示着一个一维向量，其中用于计算该类中心的这基因的表达谱数据.</li>
</ul>
<h2 id="pca主成分分析">PCA主成分分析</h2>
<p>主成分分析 (PCA) 被广泛的用于分析多维数据，一个将主成分分析应用于表达谱数据的请见 Yeung and Ruzzo (2001) [<a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr23.html#yeung2001"  target="_blank" rel="noopener"
    >33</a>].<br>
简而言之，PCA是一种坐标转换的方法，转换后的基础向量成为主成分，变换前的每行可以用主成分的 线性关系显示。主成分的选择是基于是残差尽可能的小的原则。例如，一个 <em>n</em> × 3 的数据矩阵可以表示为三维 空间内的一个椭圆球形的点的云。第一主成分是这个椭圆球形的最长轴，第二主成分是次长轴，第三主成分 是最短的轴。矩阵中，每一行都可以用主成分的线性关系展示。一般而言，为了对数据进行降维，只保留最 重要的几个主成分。剩余的残差认为是不可解释的方差。<br>
可以通过计算数据的协方差矩阵的特征向量来得到主成分。每个主成分对应的特征值决定了 其在数据中代表的方差的大小。<br>
在进行主成分分析前，矩阵的数据每一列都要减去其平均值。在上面椭圆球形云的例子中，数据在3D 空间中，围绕着其中心分布，而主成分则显示着每个点对其中心的变化。<br>
函数 pca 首先使用奇异值分解（singular value decomposition）来计算矩阵的特征值和 特征向量。奇异值分解使用的是Algol写的C语言的 svd [<a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr23.html#golub1971"  target="_blank" rel="noopener"
    >16</a>] , 利用的是 Householder bidiagonalization 和 QR 算法的变异。主成分，每个数据在主成分上的坐标和主成分 对应的特征值都会被计算出来，并按照特征值的降序排列。如果需要数据中心，则需要在调用 pca 前，对每列数据减去其平均值。<br>
将主成分分析应用于二维矩阵 data,可以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio.Cluster</span> <span class="kn">import</span> <span class="n">pca</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">columnmean</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">pca</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>函数会返回一个元组 columnmean, coordinates, components, eigenvalues :</p>
<ul>
<li><strong>columnmean</strong>包含 data 每列均值的数组 .</li>
<li><strong>coordinates</strong>data 中每行数据在主成分上对应的坐标。</li>
<li><strong>components</strong>主成分</li>
<li><strong>eigenvalues</strong>每个主成分对应的特征值
原始的数据 data 可以通过计算 columnmean + dot(coordinates, components) 得到。</li>
</ul>
<h2 id="处理clustertreeview-type文件">处理Cluster/TreeView-type文件</h2>
<p>Cluster/TreeView 是一个对基因表达数据可视化的工具。他们最初由 <a class="link" href="http://rana.lbl.gov/"  target="_blank" rel="noopener"
    >Michael Eisen</a> 在 Stanford University 完成。Bio.Cluster 包含着读写 Cluster/TreeView 对应的文件格式的函数。因此，将结果保存为该格式后， 可以用Treeview对结果进行直接的查看。我们推荐使用 Alok Saldanha 的 <a class="link" href="http://jtreeview.sourceforge.net/"  target="_blank" rel="noopener"
    >http://jtreeview.sourceforge.net/</a>Java TreeView 程序。这个软件可以显示系统聚类和 <em>k</em>-means 聚类的结果<br>
类 Record 的一个对象包含着一个 Cluster/TreeView-type数据文件需要的所有信息。 为了将结果保存到一个 Record 对象中，首先需要打开一个文件，并读取：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">Cluster</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&#34;mydatafile.txt&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">record</span> <span class="o">=</span> <span class="n">Cluster</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>两步操作使得你可以较灵活地操作不同来源的数据，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">gzip</span> <span class="c1"># Python standard library</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&#34;mydatafile.txt.gz&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>来打开一个gzipped文件，或者利用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">urllib</span> <span class="c1"># Python standard library</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&#34;http://somewhere.org/mydatafile.txt&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>来打开一个网络文件，然后调用 read.<br>
read 命令会读取一个由制表符分割的文本文件 mydatafile.txt，文件包含着 符合Michael Eisen’s Cluster/TreeView格式的基因表达数据。具体的格式说明，可以参见 Cluster/TreeView手册，链接见 <a class="link" href="http://rana.lbl.gov/manuals/ClusterTreeView.pdf"  target="_blank" rel="noopener"
    >Michael Eisen’s lab website</a> 或者 <a class="link" href="http://bonsai.ims.u-tokyo.ac.jp/~mdehoon/software/cluster/cluster3.pdf"  target="_blank" rel="noopener"
    >our website</a>.<br>
一个 Record 对象有以下的性质:</p>
<ul>
<li><strong>data</strong>包含基因表达数据的矩阵，每行为基因，每列为芯片。</li>
<li><strong>mask</strong>缺失值的整型数组。如果 mask[i,j]0, 则 data[i,j] 是缺失的. 如果 maskNone, 那么没有数据缺失。</li>
<li><strong>geneid</strong>包含每个基因的独特说明的列表 (例如 ORF 数目).</li>
<li><strong>genename</strong>包含每个基因说明的列表（例如基因名）。如果文件中不包含该数据， 那么 genename 被设为 None.</li>
<li><strong>gweight</strong>计算表达谱数据中，基因间的距离使用的权重。如果文件中不含该信息，则 gweight 为 None.</li>
<li><strong>gorder</strong>期望输出文件中基因的排列的顺序。如果文件中不含该信息，则 gorder 为<code>None</code>.</li>
<li><strong>expid</strong>包含每个芯片说明的列表，例如实验条件。</li>
<li><strong>eweight</strong>计算表达谱数据中，不同芯片间的距离使用的权重。如果文件中不含该信息，则 eweight 为 None.</li>
<li><strong>eorder</strong>期望输出文件中基因的排列的顺序。如果文件中不含该信息，则 eorder 为 None.</li>
<li><strong>uniqid</strong>用于代替文件中 UNIQID 的字符串.
在载入 Record 对象后，上述的每个性质可以直接读取和修改。例如，可以对 record.data 直接取对数来对数据进行log转换。</li>
</ul>
<h3 id="计算距离矩阵-1">计算距离矩阵</h3>
<p>为了计算record中存储元素的距离矩阵，可以用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">matrix</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">distancematrix</span><span class="p">()</span>
</span></span></code></pre></div><p>其中，包含以下参数：</p>
<ul>
<li>**transpose (默认: 0)**选择对 data 的行 (transpose0), 或者列 (transpose1)计算距离。</li>
<li>**dist (默认: &rsquo;e&rsquo;, Euclidean distance)**选择合适的元素距离算法 (见 <a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr15.html#sec-distancefunctions"  target="_blank" rel="noopener"
    >15.1</a> ).
函数会返回一个距离矩阵，每行的列数等于行数。</li>
</ul>
<h3 id="计算聚类中心">计算聚类中心</h3>
<p>为了计算存储在record中的元素的聚类中心，利用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">cmask</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">clustercentroids</span><span class="p">()</span>
</span></span></code></pre></div><ul>
<li>**clusterid (默认: None)**展示每个元素所属类的整型向量。如果缺少 clusterid,默认所有的元素属于同一类。</li>
<li>**method (默认: &lsquo;a&rsquo;)**选择使用算术平均值 (method&rsquo;a&rsquo;) 或者中值 (method&rsquo;m&rsquo;)来计算聚类中心。</li>
<li>**transpose (默认: 0)**选择计算<code>data</code> 的行 (transpose0), 或者列 (transpose1)计算中心。
函数返回元组 cdata, cmask ;</li>
</ul>
<h3 id="计算两类间的距离">计算两类间的距离</h3>
<p>为了计算存储在record中的两类的距离，利用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">clusterdistance</span><span class="p">()</span>
</span></span></code></pre></div><p>其中，包含以下参数：</p>
<ul>
<li>**index1 (默认: 0)**第一个类别所包含的元素的列表。如果一个类别只包含一个元素 <em>i</em> 可以为一个列表 [i], 或者整数 i.</li>
<li>**index2 (默认: 0)**第二个类别所包含的元素的列表。如果一个类别只包含一个元素 <em>i</em> 可以为一个列表 [i], 或者整数 i.</li>
<li>**method (默认: &lsquo;a&rsquo;)**选择计算类别间距离的方法:
<ul>
<li>&lsquo;a&rsquo;: 使用两个聚类中心的距离 (算术平均值);</li>
<li>&rsquo;m&rsquo;: 使用两个聚类中心的距离 (中值);</li>
<li>&rsquo;s&rsquo;: 使用两类中最短的两个元素之间的距离;</li>
<li>&lsquo;x&rsquo;: 使用两类中最长的两个元素之间的距离;</li>
<li>&lsquo;v&rsquo;: 使用两类中两两元素距离的平均值作为距离。</li>
</ul>
</li>
<li>**dist (默认: &rsquo;e&rsquo;, Euclidean distance)**选择使用的距离函数 (见 <a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr15.html#sec-distancefunctions"  target="_blank" rel="noopener"
    >15.1</a> ).</li>
<li>**transpose (默认: 0)**选择 使用 data 的行 ( transpose0 ), 或者列 ( transpose1 )计算距离。</li>
</ul>
<h3 id="进行系统聚类">进行系统聚类</h3>
<p>为了对存储在record中的数据进行系统聚类，利用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">treecluster</span><span class="p">()</span>
</span></span></code></pre></div><p>包含以下参数:</p>
<ul>
<li>**transpose (默认: 0)**选择使用行 ( transpose0 ) 或者列 ( transpose1 ) 用于聚类</li>
<li>**method (默认: &rsquo;m&rsquo;)**选择合适的节点距离计算方法:
<ul>
<li>method=&rsquo;s&rsquo;: 最小距离法</li>
<li>method=&rsquo;m&rsquo;: 最大距离法</li>
<li>method=&lsquo;c&rsquo;: 重心法</li>
<li>method=&lsquo;a&rsquo;: 类平均法</li>
</ul>
</li>
<li>**dist (默认: &rsquo;e&rsquo;, Euclidean distance)**选择使用的距离函数(见 <a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr15.html#sec-distancefunctions"  target="_blank" rel="noopener"
    >15.1</a> ).</li>
<li><strong>transpose</strong>选择使用基因或者芯片进行聚类，如果是 transpose0 , 则使用基因 (行) 进行聚类，如果使用 transpose1, 芯片 (列) 用于聚类.
函数返回 Tree 对象。对象包含 (元素数目 − 1） 节点, 如果使用行进行聚类时，元素数目为总行数； 当使用列进行聚类时，元素数目为总列数。每个节点描述着一对节点连接，然而节点的性质 left 和 right 包含着相邻节点所有的元素和子节点数， distance 显示着左右节点的距离。 元素从 0 到 (元素数目 − 1) 进行索引, 而类别从 -1 to −(元素数目−1)进行索引。</li>
</ul>
<h3 id="进行k-means-or-k-medians聚类">进行k-means or k-medians聚类</h3>
<p>为了对存储在record中的元素进行 <em>k</em>-means 或者 <em>k</em>-medians 聚类，可以使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">clusterid</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">nfound</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">kcluster</span><span class="p">()</span>
</span></span></code></pre></div><p>包含以下参数:</p>
<ul>
<li>**nclusters (默认: 2)**类的数目 <em>k</em>.</li>
<li>**transpose (默认: 0)**选择 使用 data 的行 ( transpose0 ), 或者列 ( transpose1 )计算距离。</li>
<li><strong>npass (默认: 1)</strong><em>k</em>-means/-medians 聚类算法运行的次数，每次运行使用不同的随机的起始值。 如果指定了 initialid , npass 的值会忽略，并且聚类算法只会运行一次。</li>
<li>**method (默认: a)**指定确定聚类中心的方法:当指定 method 使用其他值时，算法会采用算数平均值。
<ul>
<li>method=&lsquo;a&rsquo;: 算数平均值 (<em>k</em>-means clustering);</li>
<li>method=&rsquo;m&rsquo;: 中间值 (<em>k</em>-medians clustering).</li>
</ul>
</li>
<li>**dist (默认: &rsquo;e&rsquo; , Euclidean distance)**选择使用的距离函数 (见 <a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr15.html#sec-distancefunctions"  target="_blank" rel="noopener"
    >15.1</a> ).
这个函数返回的是一个元组 (clusterid, error, nfound) , 其中 clusterid 是一个每行或则列对应的类的编号。 error 是最优解的类内的距离和， nfound 是最优解被发现的次数。</li>
</ul>
<h3 id="计算self-organizing-map">计算Self-Organizing Map</h3>
<p>可以利用以下命令，计算对存储在record中元素计算 Self-Organizing Map ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">clusterid</span><span class="p">,</span> <span class="n">celldata</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">somcluster</span><span class="p">()</span>
</span></span></code></pre></div><ul>
<li>**transpose (默认: 0 )**选择 使用 data 的行 ( transpose0 ), 或者列 ( transpose1 )计算距离.</li>
<li>**nxgrid, nygrid (默认: 2, 1)**当Self-Organizing Map计算时，在矩形网格里的横向和纵向格子数目</li>
<li>**inittau (默认: 0.02)**用于SOM算法的参数 τ 的初始值。默认的 inittau 是0.02，同Michael Eisen’s Cluster/TreeView 程序中 使用的参数一致。</li>
<li>**niter (默认: 1 )**迭代运行的次数。</li>
<li>**dist (默认: &rsquo;e&rsquo; , Euclidean distance)**选择使用的距离函数(见 <a class="link" href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr15.html#sec-distancefunctions"  target="_blank" rel="noopener"
    >15.1</a> ).
函数返回一个元组 (clusterid, celldata) :</li>
<li>**clusterid:**一个二维数组，行数同待聚类的元素数目相同。每行的内容对应着该元素在矩形SOM方格内 <em>x</em> 和 <em>y</em> 的坐标。</li>
<li>**celldata:**格式为一个矩阵，如果是对行聚类，内容为 ( nxgrid , nygrid , 列数)，如果是对列聚类， 那么内容为 ( nxgrid , nygrid , 行数) 。矩阵中，坐标 [ix][iy] 对应的是该坐标的网格里的 基因表达数据的聚类中心的一维向量</li>
</ul>
<h3 id="保存聚类结果">保存聚类结果</h3>
<p>为了保存聚类结果，可以利用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">jobname</span><span class="p">,</span> <span class="n">geneclusters</span><span class="p">,</span> <span class="n">expclusters</span><span class="p">)</span>
</span></span></code></pre></div><p>包含以下参数:</p>
<ul>
<li><strong>jobname</strong>字符串 jobname 作为保存的文件名。</li>
<li><strong>geneclusters</strong>这个参数指的是基因（以行聚类）的结果。在 <em>k</em>-means 聚类中，这个参数是一个一维的数组，包含着 每个基因对应的类别，可以通过 kcluster 得到。在系统聚类中， geneclusters 是一个 Tree 对象。</li>
<li><strong>expclusters</strong>这个参数指的是实验条件（以列聚类）的结果。在 <em>k</em>-means 聚类中，这个参数是一个一维的数组，包含着 每个实验条件对应的类别，可以通过 kcluster 得到。在系统聚类中， geneclusters 是一个<code>Tree</code> 对象。
这个方法会生成文本文件 jobname.cdt, jobname.gtr, jobname.atr, jobname_.kgg, 和/或 jobname_.kag 。 这些文件可以用于后续分析。如果 geneclusters 和 expclusters 都是 None , 那这个方法只会生成 jobname.cdt ; 这个文件可以被读取，生成一个新的 Record 对象.</li>
</ul>
<h2 id="示例">示例</h2>
<p>以下是一个系统聚类的例子，其中使用最短距离法对基因进行聚类，用最大距离法对实验条件进行聚类。 由于使用 Euclidean 距离对基因进行聚类，因此需要将节点距离 genetree 进行调整，使其处于0和1之间。 这种调整对于Java TreeView正确显示树结构也是很必须的。同时使用 uncentered correlation 对实验条件进行聚类。 在这种情况下，不需要任何的调整，因为 exptree 中的结果已经位于0和2之间。 示例中使用的 文件 cyano.txt 可以从 data 文件夹中找到。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">Cluster</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&#34;cyano.txt&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">record</span> <span class="o">=</span> <span class="n">Cluster</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">genetree</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">treecluster</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">genetree</span><span class="o">.</span><span class="n">scale</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">exptree</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">treecluster</span><span class="p">(</span><span class="n">dist</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&#34;cyano_result&#34;</span><span class="p">,</span> <span class="n">genetree</span><span class="p">,</span> <span class="n">exptree</span><span class="p">)</span>
</span></span></code></pre></div><p>这个命令会生成 cyano_result.cdt , cyano_result.gtr , 和 cyano_result.atr 等文件。<br>
同样的，也可以保存一个 <em>k</em>-means 聚类的结果:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">Cluster</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&#34;cyano.txt&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">record</span> <span class="o">=</span> <span class="n">Cluster</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">geneclusters</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">ifound</span><span class="p">)</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">kcluster</span><span class="p">(</span><span class="n">nclusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">npass</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">expclusters</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">ifound</span><span class="p">)</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">kcluster</span><span class="p">(</span><span class="n">nclusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">npass</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">record</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&#34;cyano_result&#34;</span><span class="p">,</span> <span class="n">geneclusters</span><span class="p">,</span> <span class="n">expclusters</span><span class="p">)</span>
</span></span></code></pre></div><p>上述代码将生成文件 cyano_result_K_G2_A2.cdt , cyano_result_K_G2.kgg , 和 cyano_result_K_A2.kag 。s</p>
<h2 id="附加函数">附加函数</h2>
<p>median(data) 返回一维数组 data 的中值<br>
mean(data) 返回一维数组 data 的均值。<br>
version() 返回使用的C聚类库的版本号。</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/tutorials/">tutorials</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2023 叶宇浩随记博客
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#距离函数">距离函数</a>
      <ol>
        <li><a href="#euclidean距离">Euclidean距离</a></li>
        <li><a href="#city-block-distance">City-block distance</a></li>
      </ol>
    </li>
    <li><a href="#pearson相关系数">pearson相关系数</a>
      <ol>
        <li><a href="#absolute-pearson-correlation">Absolute Pearson correlation</a></li>
        <li><a href="#uncentered-correlation-夹角余弦">Uncentered correlation (夹角余弦)</a></li>
        <li><a href="#absolute-uncentered-correlation">Absolute uncentered correlation</a></li>
        <li><a href="#spearman-rank-correlation">Spearman rank correlation</a></li>
        <li><a href="#kendalls-τ">Kendall&rsquo;s τ</a></li>
      </ol>
    </li>
    <li><a href="#weighting">Weighting</a></li>
    <li><a href="#计算距离矩阵">计算距离矩阵</a></li>
    <li><a href="#计算类的相关性质">计算类的相关性质</a>
      <ol>
        <li><a href="#计算类中心">计算类中心</a></li>
        <li><a href="#计算类间距离">计算类间距离</a></li>
      </ol>
    </li>
    <li><a href="#划分算法">划分算法</a>
      <ol>
        <li><a href="#k-means-and-k-medians">K-means and k-medians</a></li>
        <li><a href="#k-medoids聚类">k-medoids聚类</a></li>
      </ol>
    </li>
    <li><a href="#系统聚类">系统聚类</a>
      <ol>
        <li><a href="#展示系统聚类的结果">展示系统聚类的结果</a></li>
        <li><a href="#运行系统聚类">运行系统聚类</a></li>
      </ol>
    </li>
    <li><a href="#self-organizing-maps">Self-Organizing Maps</a></li>
    <li><a href="#pca主成分分析">PCA主成分分析</a></li>
    <li><a href="#处理clustertreeview-type文件">处理Cluster/TreeView-type文件</a>
      <ol>
        <li><a href="#计算距离矩阵-1">计算距离矩阵</a></li>
        <li><a href="#计算聚类中心">计算聚类中心</a></li>
        <li><a href="#计算两类间的距离">计算两类间的距离</a></li>
        <li><a href="#进行系统聚类">进行系统聚类</a></li>
        <li><a href="#进行k-means-or-k-medians聚类">进行k-means or k-medians聚类</a></li>
        <li><a href="#计算self-organizing-map">计算Self-Organizing Map</a></li>
        <li><a href="#保存聚类结果">保存聚类结果</a></li>
      </ol>
    </li>
    <li><a href="#示例">示例</a></li>
    <li><a href="#附加函数">附加函数</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
